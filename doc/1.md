[TOC]

+ **source命令**，也称“点**命令**”，也就是一个点符号（.），是bash的内部**命令**。 功能：使shell读入指定的shell程序文件并依次执行文件中的所有语句。 该**命令**通常用于重新执行刚修改的初始化文件，使之立即生效，而不必注销并重新登录。

+ `cargo` 命令 `cargo new 工程名` 建立一个新的工程。

+ 在 `rust` 中定义变量的时候，其默认是不可变的变量。 `let a = 1` 这样定义的一个变量是不可变的。如果想让其变成一个可变的变量需要加上 `mut` ， `let mut b = 1` 这样。

+ 在后面声明同名的变量可以把前面的同名变量隐藏掉

  ```rust
  let a : u32 = 1;
  let a : f32 = 1.1;
  println!("a = {}", a);
  ```

  输出为

  >1.1

  这里后面的 `a : f32` 将前面的 `a : u32` 隐藏掉了。

+ 如果要定义一个常量，可以用 `const` 。

  ```rust
  const MAX_POINTS : u32 : 10000;
  ```

+ `rust` 是静态类型语言，编译时必须知道所有变量的类型

+ 编译器具有自动推导的能力。没有写变量的类型的话编译器可以自动推断出变量的类型。

+ 在 `rust` 里面一个字符类型是 `32` 位的。其可以存储一个汉字。

+ 自适应类型和数组

  ![image-20210701131205914](https://cdn.jsdelivr.net/gh/smallzhong/new-picgo-pic-bed@master/image-20210701131205914.png)

  + `rust` 和 `c/c++` 类似，数组下标从0开始。

  + `size` 也是数组类型的一部分。不像 `c/c++` 。

+ 元组

  ![image-20210701132143221](https://cdn.jsdelivr.net/gh/smallzhong/new-picgo-pic-bed@master/image-20210701132143221.png)

+ 元组的拆解

  ![image-20210701132333248](https://cdn.jsdelivr.net/gh/smallzhong/new-picgo-pic-bed@master/image-20210701132333248.png)

+ 函数的使用

  ![image-20210701133205200](https://cdn.jsdelivr.net/gh/smallzhong/new-picgo-pic-bed@master//image-20210701133205200.png)

+ 还可以这样不写 `return` 。不过在最后不能加 `;` 。

  ![image-20210701134241791](C:\Users\雨初\AppData\Roaming\Typora\typora-user-images\image-20210701134241791.png)

+ 语句不会返回值。不像其他语言一样有返回值。比如 `let x = (let y = 1);` 这样的语句是编译不通过的。会报错。但是这样就可以。

  ![image-20210701134651198](https://cdn.jsdelivr.net/gh/smallzhong/new-picgo-pic-bed@master//image-20210701134651198.png)

### 控制流

+ `if-else` 的判断语句不加括号。

    ```rust
    let y = 1;
    if y == 1
    {
    println!("y == 1");
    }
    else
    {
    println!("y != 1")
    }
    ```

+ 循环

  ```rust
  let mut counter = 0;
  loop {
      println!("in loop");
      if counter == 10 {
          break;
      }
      
      counter += 1;
  }
  ```
  
  通过 `loop` 进行循环， `break` 跳出循环。
  
+ `while` 循环

    ```rust
    let mut i = 0;
    while i != 10 {
        println!("i = {}", i);
        i += 1;
    }
    ```

+ `for` 循环

    ```rust
    let arr : [u32; 5] = [1, 2, 3, 4, 5];
    for (element in arr.iter()) {
        println!("element = {}", element);
    }
    ```

### 所有权机制

+ 分配在栈上的数据需要大小固定。

+ `String` 类型离开作用域的时候会调用 `drop` 方法。类似于 `c++` 中的析构函数。

+ 为了防止 `double free` ，在移动了之后原来的字符串会无效。

  ![image-20210701150115366](https://cdn.jsdelivr.net/gh/smallzhong/new-picgo-pic-bed@master//image-20210701150115366.png)

  像这样，在 `s2 = s1` 之后 `s1` 就无效了。不能再使用。如果最后一句话没有被注释掉会编译失败。

+ 如果想要在拷贝一个 `String` 之后在拷贝之后的元素中和拷贝之前的元素中都可以使用，那么不能简单使用 `s2 = s1` 这样的浅拷贝。要使用 `s2 = s1.clone()` 这样，调用 `clone` 方法进行深拷贝。

+ ```rust
  fn takes_ownership(some_string : String)
  {
      println!("some_string = {}", some_string);
  }
  
  fn main()
  {
      let s = String::from("hello");
      takes_ownership(s);
  
      // println!("s = {}", s);
  }
  ```

  像这样，把这个字符串传入了 `takes_ownership` 函数中，然后在打印出来之后已经离开了这个作用域，这个时候 `s` 这个字符串已经被回收了。这时候不能再使用这个字符串。如果把注释掉的那一行取消注释会报错。

  而如果想要在获得所有权之后原来这里还能使用这个变量，可以将其通过返回值重新传回来，这样就可以继续使用这个函数了。像这样

  ```rust
  fn takes_ownership(some_string : String) -> String
  {
      println!("some_string = {}", some_string);
  
      some_string
  }
  
  fn main()
  {
      let s = String::from("hello");
      let ret = takes_ownership(s);
  
      println!("ret = {}", ret);
  }
  ```

+ 像这样把一个变量进行返回，则这个变量进行了所有权的转移。其作用域转移到了 `main` 函数之中。

  ```rust
  fn gives_ownership() -> String
  {
      let a = String::from("test");
      a
  }
  
  fn main()
  {
      let s = gives_ownership();
      
      println!("s = {}", s);
  }
  ```

### 引用

+ 使用引用时，在定义函数参数的时候在参数的类型前面加上一个 `&` 。在传参的时候，和 `c++` 不同，这里也要加上一个 `&` 。`rust` 没有指针。

  ```rust
  fn gives_ownership() -> String
  {
      let a = String::from("test");
      a
  }
  
  fn test(a : &String) -> usize {
      return a.len();
  }
  
  fn main() {
      let s = gives_ownership();
      println!("s = {}", s);
  
      println!("test = {}", test(&s));
  
      println!("s = {}", s);
  }
  ```

  这样的话向函数中传入的只是一个引用，不是原来的元素。这样在离开函数的作用域之后这个元素也不会失效，因为其本身并不属于这个作用域。